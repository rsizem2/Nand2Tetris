/** Implements a graphical ball with velocity and collision detection. */
class Ball {

	// these values are updated separately for each instance of ball
	field int pos_x, pos_y; 	// screen location of the ball's center
	field int vel_x, vel_y;		// x and y speed of the ball

	field int min_x, max_x;		// min and max x positions
	field int min_y, max_y;		// min and max y positions
	field int radius; 			// radius of the ball, in pixels


	/** Constructs a new ball with a center, velocity and radius. */
	constructor Ball new(int posX, int posY, int velX, int velY) {
		let pos_x = posX;
		let pos_y = posY;
		let vel_x = velX;
		let vel_y = velY;
		let radius = 20;
		let min_x = radius + 1;		// min/max keeps program from drawing out of bounds
		let max_x = 512 - min_x;
		let min_y = 12 + radius;
		let max_y = 256 - min_x;
		do draw();
		return this;
	}

	/** Getters */
	method int get_x()   {return pos_x;}
	method int get_y()   {return pos_y;}


	/** Setters */
	method void flip_x() {
		let vel_x = -vel_x;
		return;
		}
	method void flip_y() {
		let vel_y = -vel_y;
		return;
		}

	/** Disposes this ball object. */
	method void dispose() {
		do erase();
		do Memory.deAlloc(this);
		return;
	}

	/** Draws the ball on the screen. */
	method void draw() {
		do Screen.setColor(true);
		do Screen.drawCircle(pos_x, pos_y, radius);
		return;
	}

	/** Erases the ball from the screen. */
	method void erase() {
		do Screen.setColor(false);
		do Screen.drawCircle(pos_x, pos_y, radius);
		return;
	}

	/** Moves the ball based on the velocity. */
	method void move() {
		do Screen.setColor(false);
        do Screen.drawCircle(pos_x, pos_y, radius);
		if ((pos_x + vel_x) > max_x) {
			// ball will be too far right on next iteration
			let pos_x = max_x;
			let vel_x = -vel_x;
		}
		else {
			if ((pos_x + vel_x) < min_x) {
				// ball will be too far left on next iteration
				let pos_x = min_x;
				let vel_x = -vel_x;
			}
			else {
				// ball is not near vertical walls
				let pos_x = pos_x + vel_x;
			}
		}
		if ((pos_y + vel_y) > max_y) {
			// ball will be too high on next iteration
			let pos_y = max_y;
			let vel_y = -vel_y;
		}
		else {
			if ((pos_y + vel_y) < min_y) {
				// ball will be too low on next iteration
				let pos_y = min_y;
				let vel_y = -vel_y;
			}
			else {
				// ball is not near horizontal walls
				let pos_y = pos_y + vel_y;
			}
		}
		do Screen.setColor(true);
		do Screen.drawCircle(pos_x, pos_y, radius);
		return;
	}

	/** Checks for collision between two balls **/
	method void collide(Ball other){

		var int dist_x, dist_y;

		let dist_x = Math.abs(pos_x - other.get_x());
		let dist_y = Math.abs(pos_y - other.get_y());

		if ((dist_x + dist_y) < Math.multiply(2,radius)){
			//collision occurs
			do other.flip_x();
			do other.flip_y();
			do flip_x();
			do flip_y();
		}
		return;
	}
}
